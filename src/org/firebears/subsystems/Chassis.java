package org.firebears.subsystems;

import org.firebears.RobotMap;
import org.firebears.commands.*;
import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;

/**
 * Chassis.java
 */
public class Chassis extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    CANJaguar frontRightJag = RobotMap.chassisFrontRightJag;
    CANJaguar rearRightJag = RobotMap.chassisRearRightJag;
    CANJaguar frontLeftJag = RobotMap.chassisFrontLeftJag;
    CANJaguar rearLeftJag = RobotMap.chassisRearLeftJag;
    RobotDrive robotDrive = RobotMap.chassisRobotDrive;
    Gyro gyro = RobotMap.chassisGyro;
    Encoder leftEncoder = RobotMap.chassisLeftEncoder;
    Encoder rightEncoder = RobotMap.chassisRightEncoder;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        if (robotDrive != null) {
            // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
            setDefaultCommand(new ChassisDriveWithJoystick());
            // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        }
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
     public void SlowMode(GenericHID stick1) {
        robotDrive.arcadeDrive(stick1.getY() * .6, stick1.getX() * .6);
    }

   public void arcadeDrive(double moveValue, double rotateValue ) {
        robotDrive.arcadeDrive(moveValue, rotateValue);
    } 

    /**
     * @return the gyro angle in the range -180 to 180.
     */
    public double getGyroAngle() {
        double angle = gyro.getAngle();
        if (angle > 180) {
            angle -= 360;
        } else if (angle < -180) {
            angle += 360;
        }
        return fixAngle(angle, 180);
    }

    /**
     * Wrap an angle to a range of 360 degrees. The gyro may return values
     * outside the range -360 to 360. This method fixes all angles into a
     * reasonable range.
     */
    private double fixAngle(double a, double maxAngle) {
        double angle = a;
        double minAngle = maxAngle - 360;
        while (angle < minAngle || angle > maxAngle) {
            if (angle > maxAngle) {
                angle -= 360;
            } else if (angle < minAngle) {
                angle += 360;
            } else {
                break;
            }
        }
        return angle;
    }


/**
 * Simple joystick smoothing function that squares the jostick values while preserving the sign.
 * @param stick the joystickvalue to attempt to smooth
 */
double joystickSmoothing(double stick){
  if( stick < 0 ){
    return -1.0 * stick * stick;
  }
  else{
    return stick * stick;
  }
} 

/**
 * Simple joystick smoothing function that cubes the jostick values while preserving the sign.
 * @param stick the joystickvalue to attempt to smooth
 */
double joystickSmoothingCube(double stick){
	  return stick * stick * stick;
	} 
   
    
    //    public void TurnLeft() {
//        robotDrive.arcadeDrive(0, .7);
//    }
//
//    public void TurnRight() {
//        robotDrive.arcadeDrive(0, -.7);
//    }

//    public void AutoPart1(double speed, double rotation) {
//        robotDrive.arcadeDrive(-speed, rotation);
//    }
//
//    public void AutoPart2() {
//        robotDrive.arcadeDrive(0, -.5);
//    }
}
