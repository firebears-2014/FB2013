package org.firebears.subsystems;

import com.sun.squawk.microedition.io.FileConnection;
import com.sun.squawk.util.Arrays;
import edu.wpi.first.wpilibj.camera.AxisCamera;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.image.BinaryImage;
import edu.wpi.first.wpilibj.image.ColorImage;
import edu.wpi.first.wpilibj.image.Image;
import edu.wpi.first.wpilibj.image.NIVisionException;
import edu.wpi.first.wpilibj.image.ParticleAnalysisReport;
import edu.wpi.first.wpilibj.image.RGBImage;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Enumeration;
import java.util.Vector;
import javax.microedition.io.Connector;
import org.firebears.RobotMap;
import org.firebears.commands.camera.Filter;
import org.firebears.commands.camera.ProcessingPlan;

/**
 * Subsystem wrapped around the Axis Camera, allowing processing of images into
 * particles. <p>Typically, the {@code Camera} will be used like this:
 * <pre>
 * ProcessingPlan plan = new RectangleTargetPlan(52, 22);
 *
 * camera.reset();
 * camera.takePicture();
 * camera.processImage(plan, false);
 *
 * ParticleAnalysisReport particle = camera.getBestParticle();
 * if (particle != null) {
 * double distance = Camera.estimateDistance(particle);
 * double angle = Camera.estimateAngle(particle, distance);
 * <em>turn angle and shoot distance</em>
 * }
 * </pre>
 */
public class Camera extends Subsystem {

    AxisCamera axisCamera = RobotMap.axisCamera;
    private ColorImage colorImage = null;
    private Vector pictureFileList = new Vector();
    private ParticleAnalysisReport[] particleList = null;
    private boolean hasPicture = false;
    private double angle = 0;
    private double distance = 0;
    private int targetType = 0;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    }

    /**
     * Reset camera and free internal images.
     */
    public void reset() {
        try {
            if (this.colorImage != null) {
                this.colorImage.free();
                this.colorImage = null;
            }
            this.particleList = null;
            pictureFileList.setSize(0);
        } catch (NIVisionException e) {
            e.printStackTrace();
        }
        hasPicture = false;
        angle = 0;
        distance = 0;
        targetType = 0;
    }

    /**
     * Take a picture and save the image.
     *
     * @return whether the image was successfully captured.
     */
    public boolean takePicture() {
        if (!axisCamera.freshImage()) {
            log("::: Axis Camera has no picture");
            return false;
        }
        try {
            reset();
            this.colorImage = axisCamera.getImage();
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    /**
     * Load an image from a file on the cRIO. This can be used for testing the
     * image processing, by reloading an image file previously saved to the
     * cRIO.
     *
     * @param filename Full file path on cRIO's file system.
     * @return whether image was successfully loaded.
     */
    public boolean loadPicture(String filename) {
        try {
            reset();
            colorImage = new RGBImage(filename);
        } catch (NIVisionException ex) {
            ex.printStackTrace();
            return false;
        }
        return true;
    }

    /**
     * Process image.
     *
     * @param plan determines filters and sorting criteria.
     * @param saveFiles Whether to save intermediate files.
     * @return whether processing finished.
     */
    public boolean processImage(ProcessingPlan plan, boolean saveFiles) {
        long time = System.currentTimeMillis();
        Image image = null;
        try {
            image = this.colorImage;
            if (saveFiles) {
                String filename = "camera_" + time + "_0.jpg";
                image.write("/tmp/" + filename);
                pictureFileList.addElement(filename);
                log("::: Saved /tmp/" + filename);
            }
            Enumeration filterList = plan.getFilterList().elements();
            int count = 1;
            while (filterList.hasMoreElements()) {
                Filter filter = (Filter) filterList.nextElement();
                Image newImage = filter.process(image);
                if (image != colorImage) {
                    image.free();
                }
                image = newImage;
                if (saveFiles) {
                    String filename = "camera_" + time + "_" + count + ".bmp";
                    image.write("/tmp/" + filename);
                    pictureFileList.addElement(filename);
                    log("::: Saved /tmp/" + filename);
                }
                count++;
            }
            particleList = ((BinaryImage) image).getOrderedParticleAnalysisReports();
            Arrays.sort(particleList, plan);
            if (saveFiles) {
                String filename = "/tmp/camera_" + time + "_0.html";
                FileConnection fc = (FileConnection) Connector.open("file:///"
                        + filename, Connector.WRITE);
                fc.create();
                PrintStream out = new PrintStream(fc.openOutputStream());
                printParticleReport(time, plan, out, (System.currentTimeMillis() - time));
                fc.close();
                log("::: Saved " + filename);
            }
            if (image != colorImage) {
                image.free();
            }
            image = null;
        } catch (NIVisionException ex) {
            ex.printStackTrace();
            return false;
        } catch (IOException iox) {
            iox.printStackTrace();
        } finally {
            if (image != null && image != colorImage) {
                try {
                    image.free();
                } catch (Exception e) {
                }
            }
            long timeUsed = System.currentTimeMillis() - time;
            log("::: processImage(" + time + ") : " + timeUsed + " ms");
        }
        if (particleList == null || particleList.length == 0) {
            hasPicture = false;
            angle = 0;
            distance = 0;
            targetType = 0;
        } else {
            hasPicture = true;
            distance = plan.estimateDistance(particleList);
            angle = plan.estimateHorizontalAngle(particleList, distance);
            targetType = plan.getTargetType(particleList);
        }
        return true;
    }

    public boolean hasPicture() {
        return hasPicture;
    }

    /**
     * @return distance in inches
     */
    public double getDistance() {
        return distance;
    }

    /**
     * @return angle in degrees
     */
    public double getAngle() {
        return angle;
    }

    /**
     * @return target type number. Zero indicates unknown.
     */
    public int getTargetType() {
        return targetType;
    }

    /**
     * After completing {@code processImage()}, this method will return all
     * particles. Will return {@code null} if processing of the image hasn't
     * completed. Will return an empty array if no good particles were found.
     *
     * @return an array of particles or {@code null}.
     */
    public ParticleAnalysisReport[] getAllParticles() {
        return particleList;
    }

    /**
     * After completing {@code processImage()}, this method can generate an HTML
     * file describing the results.
     */
    protected void printParticleReport(long time, ProcessingPlan plan, PrintStream out, long timeUsed) {
        out.println("<!doctype html>");
        out.println("<html>");
        out.println("<head>");
        out.println("\t<meta charset=\"utf-8\">");
        out.println("\t<title>" + time + "</title>");
        out.println("\t<style>"
                + " body {font-family: Arial, Helvetica, Sans-serif;}"
                + " table {font-size: SMALL; } "
                + "</style>");
        out.println("</head>");
        out.println("<body>");
        {
            out.println("<h1>Picture " + time + "</h1>");
            out.println("\n\n<br/><h3>Camera</h3>");
            out.println("<ul>");
            out.println("\t<li>brightness = "
                    + axisCamera.getBrightness() + "</li>");
            out.println("\t<li>colorLevel = "
                    + axisCamera.getColorLevel() + "</li>");
            out.println("\t<li>whiteBalance = "
                    + axisCamera.getWhiteBalance().value + "</li>");
            out.println("\t<li>exposureControl = "
                    + axisCamera.getExposureControl().value + "</li>");
            double dist = plan.estimateDistance(particleList);
            double angle = plan.estimateHorizontalAngle(particleList, dist);
            out.println("\t<li>distance = " + Math.ceil(dist) + "</li>");
            out.println("\t<li>angle = " + Math.ceil(angle) + "</li>");
            if (RobotMap.chassisGyro != null) {
                out.println("\t<li>Gyro = " + RobotMap.chassisGyro.getAngle() + "</li>");
            }
            out.println("</ul>");
        }
        out.println("\n\n<br/><h3>Particle Analysis</h3>");
        if (particleList == null || particleList.length == 0) {
            out.println("\t<p>No particles returned</p>");
        } else {
            out.println("<blockquote>");
            out.println("\t<table><thead>");
            out.println("\t<tr><th>n</th><th>location</th><th>size</th>"
                    + "<th>area</th><th>distance</th><th>angle</th>"
                    + "<th>ratio</th><th>score</th><th>type</th>"
                    + "<th></th><th>vAngle</th><th>percentage</th></tr>");
            out.println("\t</thead><tbody>");
            ParticleAnalysisReport[] pa = new ParticleAnalysisReport[1];
            for (int n = 0; n < particleList.length; n++) {
                ParticleAnalysisReport p = particleList[n];
                pa[0] = p;
                double dist = plan.estimateDistance(pa);
                double angle = plan.estimateHorizontalAngle(pa, dist);
                out.println("\t<tr>");
                out.println("\t\t<td>" + n + "</td>");
                out.println("\t\t<td>" + p.boundingRectLeft + ", "
                        + p.boundingRectTop + "</td>");
                out.println("\t\t<td>" + p.boundingRectWidth + ", "
                        + p.boundingRectHeight + "</td>");
                out.println("\t\t<td>" + p.particleArea + "</td>");
                out.println("\t\t<td>" + Math.ceil(dist) + "</td>");
                out.println("\t\t<td>" + Math.ceil(angle) + "</td>");
                double ratio = (p.boundingRectWidth + 4.0) / (p.boundingRectHeight + 4.0);
                out.println("\t\t<td>" + (Math.ceil(ratio * 100.0) / 100.0) + "\t\t</td>");
                out.println("\t\t<td>" + plan.score(p) + "</td>");
                out.println("\t\t<td>" + plan.getTargetType(p) + "</td>");
                out.println("\t\t<td></td><td>" + Math.ceil(plan.estimateVerticalAngle(pa, dist)) + "</td>");
                double pct = Math.ceil(p.particleToImagePercent * 100) / 100.0;
                out.println("\t\t<td>" + pct + "</td>");
                out.println("\t</tr>");
            }
            out.println("\t</tbody></table>");
            out.println("</blockquote>");
        }
        out.println("\n<p></p>\n");
        out.println("processing time = " + timeUsed + " ms<br/>");
        out.println("\n\n<br/><h3>Pictures</h3>");
        Enumeration filterEnum = plan.getFilterList().elements();
        Enumeration pictureEnum = pictureFileList.elements();
        while (pictureEnum.hasMoreElements()) {
            String filename = (String) pictureEnum.nextElement();
            out.println("\t<br/><img src=\"" + filename
                    + "\" alt=\"" + filename + "\" />");
            if (filterEnum.hasMoreElements()) {
                Filter filter = (Filter) filterEnum.nextElement();
                out.println("\t\t<br/>" + filter);
            }
        }
        out.println("\n\n<br/><h3>Processing Plan</h3>");
        out.println("\t" + plan + "<br/>");
        out.println("<ol>");
        filterEnum = plan.getFilterList().elements();
        while (filterEnum.hasMoreElements()) {
            Filter filter = (Filter) filterEnum.nextElement();
            out.println("\t<li>" + filter + "</li>");
        }
        out.println("</ol>");
        out.println("\n\n</body></html>");
        out.flush();
    }

    /**
     * Print a message out to the console.
     */
    private void log(String msg) {
        if (RobotMap.DEBUG) {
            System.out.println(msg);
        }
    }
}
